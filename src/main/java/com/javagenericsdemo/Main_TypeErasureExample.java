package com.javagenericsdemo;

import java.util.ArrayList;
import java.util.List;

/**
 * Demonstrates type erasure in Java Generics.
 * 
 * Type erasure is the process by which the Java compiler removes all type parameters
 * and replaces them with their bounds or Object if unbounded, after performing type checks.
 * 
 * This has several important implications:
 * 1. Generic type information is only available at compile time, not runtime
 * 2. You cannot create arrays of generic types
 * 3. You cannot use instanceof with generic types
 * 4. You cannot overload methods that would have the same erasure
 */
public class Main_TypeErasureExample {
    
    public static void main(String[] args) {
        System.out.println("=== Demonstrating Type Erasure in Generics ===");
        
        // 1. Runtime type information is lost
        System.out.println("\n1. Runtime Type Information Loss:");
        
        List<String> stringList = new ArrayList<>();
        List<Integer> integerList = new ArrayList<>();
        
        // Both have the same runtime class!
        System.out.println("stringList class: " + stringList.getClass());
        System.out.println("integerList class: " + integerList.getClass());
        System.out.println("Are classes equal? " + (stringList.getClass() == integerList.getClass()));
        
        // 2. Method overloading limitations
        System.out.println("\n2. Method Overloading Limitations:");
        
        // processElements method - see below for details on why these can't be overloaded
        
        // 3. Type information at runtime - workarounds
        System.out.println("\n3. Type Information Workarounds:");
        
        Box<Integer> intBox = new Box<>(42);
        Box<String> stringBox = new Box<>("Hello");
        
        System.out.println("intBox contains: " + intBox.get() + " of type: " + intBox.getTypeClass().getSimpleName());
        System.out.println("stringBox contains: " + stringBox.get() + " of type: " + stringBox.getTypeClass().getSimpleName());
        
        // 4. Bridge methods generated by the compiler
        System.out.println("\n4. Bridge Methods Example:");
        
        // Bridge methods are synthetic methods created by the compiler to support
        // generic inheritance. They're not visible in the source code.
        
        Node<Integer> intNode = new IntNode(1);
        Node<String> stringNode = new StringNode("Hello");
        
        System.out.println("intNode data: " + intNode.getData());
        System.out.println("stringNode data: " + stringNode.getData());
        
        // Demonstrate type erasure consequences
        System.out.println("\n*** WHY TYPE ERASURE EXISTS ***");
        System.out.println("Type erasure was introduced for backward compatibility with");
        System.out.println("pre-Java 5 code. It allows generic code to be used with");
        System.out.println("legacy code that doesn't understand generics.");
        System.out.println("\nAfter compilation, generic types are erased to:");
        System.out.println("1. Object - for unbounded type parameters (<T>)");
        System.out.println("2. The bound - for bounded type parameters (<T extends Number>)");
        
        System.out.println("\n*** TYPE ERASURE LIMITATIONS ***");
        System.out.println("1. Cannot create arrays of generic types directly");
        System.out.println("   Wrong: new T[10]; // Compile error!");
        System.out.println("   Right: (T[]) new Object[10]; // Unchecked cast warning");
        
        System.out.println("\n2. Cannot use instanceof with generic types");
        System.out.println("   Wrong: obj instanceof List<String>; // Compile error!");
        System.out.println("   Right: obj instanceof List; // Raw type check only");
        
        System.out.println("\n3. Cannot overload methods that would have the same erasure");
        System.out.println("   void process(List<String> list) and void process(List<Integer> list)");
        System.out.println("   both become void process(List list) after erasure");
        
        System.out.println("\n4. Cannot create instances of type parameters");
        System.out.println("   Wrong: new T(); // Compile error!");
        System.out.println("   Right: Pass a Class<T> or factory method");
    }
    
    // DEMONSTRATION: Method overloading limitation
    
    // Only one of these can exist due to type erasure
    public static void processElements(List<String> elements) {
        System.out.println("Processing strings: " + elements);
    }
    
    // This would cause a compile error if uncommented
    // public static void processElements(List<Integer> elements) {
    //     System.out.println("Processing integers: " + elements);
    // }
    
    // Instead, you need to use different method names or different parameter types
    public static void processIntegers(List<Integer> elements) {
        System.out.println("Processing integers: " + elements);
    }
    
    /**
     * This class retains type information at runtime by storing the Class object.
     * This is a common workaround for type erasure.
     */
    static class Box<T> {
        private T value;
        private Class<?> typeClass;
        
        public Box(T value) {
            this.value = value;
            this.typeClass = value.getClass();
        }
        
        public T get() {
            return value;
        }
        
        public Class<?> getTypeClass() {
            return typeClass;
        }
    }
    
    /**
     * Base class to demonstrate bridge methods
     */
    static class Node<T> {
        protected T data;
        
        public Node(T data) {
            this.data = data;
        }
        
        public T getData() {
            return data;
        }
    }
    
    /**
     * Subclass with Integer type
     * After erasure, this class would have getData() return Object,
     * but we want it to return Integer specifically.
     * The compiler creates a bridge method to handle this.
     */
    static class IntNode extends Node<Integer> {
        public IntNode(Integer data) {
            super(data);
        }
        
        @Override
        public Integer getData() {
            System.out.println("IntNode's getData() called");
            return data;
        }
    }
    
    /**
     * Subclass with String type
     */
    static class StringNode extends Node<String> {
        public StringNode(String data) {
            super(data);
        }
        
        @Override
        public String getData() {
            System.out.println("StringNode's getData() called");
            return data;
        }
    }
}
