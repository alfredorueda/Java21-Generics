package com.javagenericsdemo;

import java.util.ArrayList;
import java.util.List;

/**
 * Demonstrates type erasure in Java Generics for OCP Java 21 preparation.
 * 
 * Type erasure is the fundamental implementation mechanism behind Java's generics system.
 * It's the process by which the Java compiler removes all type parameters and type arguments
 * from generic types after performing compile-time type checks, replacing them with:
 * - Their bounds (if the type parameter has bounds)
 * - Object (if the type parameter is unbounded)
 * 
 * CORE CONCEPT:
 * Java generics exist only at compile time. After compilation, all generic type
 * information is erased, and the bytecode contains only regular Java classes,
 * interfaces, and methods - as if generics never existed.
 * 
 * CRITICAL IMPLICATIONS:
 * 1. Generic type information is only available at compile time, not runtime
 * 2. You cannot create arrays of generic types (new T[10])
 * 3. You cannot use instanceof with generic types (obj instanceof List<String>)
 * 4. You cannot overload methods that would have the same erasure
 * 5. You cannot create instances of type parameters (new T())
 * 
 * MENTAL MODEL:
 * Think of generics as a "compile-time fiction" - a sophisticated type-checking
 * system that exists only during compilation. At runtime, the JVM sees only
 * regular Java classes with appropriate casts inserted by the compiler.
 * 
 * REAL-WORLD ANALOGY:
 * Imagine a building blueprint with detailed color coding for different types
 * of rooms (living rooms in blue, kitchens in red, etc.). When the actual building
 * is constructed, the colors disappear - the rooms are all just rooms, though
 * they were built according to the specifications in the blueprint.
 * 
 * OCP EXAM TIP:
 * Type erasure is heavily tested on the OCP exam. Be prepared for questions about:
 * - What code will/won't compile due to type erasure
 * - How generic types are represented at runtime
 * - Understanding bridge methods and their purpose
 * - Common workarounds for type erasure limitations
 */
public class Main_TypeErasureExample {
    
    public static void main(String[] args) {
        System.out.println("=== Demonstrating Type Erasure in Generics ===");
        
        // 1. Runtime type information is lost
        // This is the most fundamental consequence of type erasure
        System.out.println("\n1. Runtime Type Information Loss:");
        
        List<String> stringList = new ArrayList<>();
        List<Integer> integerList = new ArrayList<>();
        
        // Both have the same runtime class!
        // After type erasure, both are just ArrayList objects
        System.out.println("stringList class: " + stringList.getClass());
        System.out.println("integerList class: " + integerList.getClass());
        System.out.println("Are classes equal? " + (stringList.getClass() == integerList.getClass()));
        
        // 2. Method overloading limitations
        // This is a direct consequence of type erasure - two methods with
        // different generic parameters would have the same signature after erasure
        System.out.println("\n2. Method Overloading Limitations:");
        
        // processElements method - see below for details on why these can't be overloaded
        
        // 3. Type information at runtime - workarounds
        // Since type erasure removes generic information, we need workarounds to
        // preserve type information if needed at runtime
        System.out.println("\n3. Type Information Workarounds:");
        
        Box<Integer> intBox = new Box<>(42);
        Box<String> stringBox = new Box<>("Hello");
        
        System.out.println("intBox contains: " + intBox.get() + " of type: " + intBox.getTypeClass().getSimpleName());
        System.out.println("stringBox contains: " + stringBox.get() + " of type: " + stringBox.getTypeClass().getSimpleName());
        
        // 4. Bridge methods generated by the compiler
        // Bridge methods are a compiler-generated mechanism to make generics work with inheritance
        System.out.println("\n4. Bridge Methods Example:");
        
        // Bridge methods are synthetic methods created by the compiler to support
        // generic inheritance. They're not visible in the source code but exist in the bytecode.
        
        Node<Integer> intNode = new IntNode(1);
        Node<String> stringNode = new StringNode("Hello");
        
        System.out.println("intNode data: " + intNode.getData());
        System.out.println("stringNode data: " + stringNode.getData());
        
        // Demonstrate type erasure consequences
        // This educational section explains why type erasure exists
        System.out.println("\n*** WHY TYPE ERASURE EXISTS ***");
        System.out.println("Type erasure was introduced for backward compatibility with");
        System.out.println("pre-Java 5 code. It allows generic code to be used with");
        System.out.println("legacy code that doesn't understand generics.");
        System.out.println("\nAfter compilation, generic types are erased to:");
        System.out.println("1. Object - for unbounded type parameters (<T>)");
        System.out.println("2. The bound - for bounded type parameters (<T extends Number>)");
        
        System.out.println("\n*** TYPE ERASURE LIMITATIONS ***");
        System.out.println("1. Cannot create arrays of generic types directly");
        System.out.println("   Wrong: new T[10]; // Compile error!");
        System.out.println("   Right: (T[]) new Object[10]; // Unchecked cast warning");
        
        System.out.println("\n2. Cannot use instanceof with generic types");
        System.out.println("   Wrong: obj instanceof List<String>; // Compile error!");
        System.out.println("   Right: obj instanceof List; // Raw type check only");
        
        System.out.println("\n3. Cannot overload methods that would have the same erasure");
        System.out.println("   void process(List<String> list) and void process(List<Integer> list)");
        System.out.println("   both become void process(List list) after erasure");
        
        System.out.println("\n4. Cannot create instances of type parameters");
        System.out.println("   Wrong: new T(); // Compile error!");
        System.out.println("   Right: Pass a Class<T> or factory method");
    }
    
    // DEMONSTRATION: Method overloading limitation
    
    /**
     * This method processes a list of strings.
     * 
     * TYPE ERASURE IMPACT:
     * After type erasure, this method signature becomes:
     * public static void processElements(List elements)
     * 
     * This is why we cannot define another method with the signature:
     * public static void processElements(List<Integer> elements)
     * 
     * OCP EXAM TIP:
     * The exam often tests understanding of method overloading with generics.
     * Remember that after type erasure, the JVM cannot distinguish between
     * methods that differ only in their generic type parameters.
     * 
     * @param elements A list of String objects to process
     */
    public static void processElements(List<String> elements) {
        System.out.println("Processing strings: " + elements);
    }
    
    // This would cause a compile error if uncommented - due to type erasure
    // public static void processElements(List<Integer> elements) {
    //     System.out.println("Processing integers: " + elements);
    // }
    
    /**
     * Instead of overloading based on generic parameters (which doesn't work),
     * we use different method names to handle different generic types.
     * 
     * PRACTICAL SOLUTION:
     * This is the standard pattern used throughout the JDK when different
     * behavior is needed for different generic types.
     * 
     * @param elements A list of Integer objects to process
     */
    public static void processIntegers(List<Integer> elements) {
        System.out.println("Processing integers: " + elements);
    }
    
    /**
     * This class retains type information at runtime by storing the Class object.
     * 
     * WORKAROUND PATTERN:
     * This is a common workaround for type erasure when you need to know
     * the actual type at runtime. By storing the Class object, we can
     * access type information that would otherwise be erased.
     * 
     * PRACTICAL APPLICATIONS:
     * This pattern is used in frameworks like Jackson, GSON, and JPA
     * that need to know the actual types for serialization/deserialization.
     * 
     * OCP EXAM TIP:
     * Understand common workarounds for type erasure limitations.
     * This pattern of storing Class<?> objects is one of the most common.
     * 
     * @param <T> The type of value stored in the box
     */
    static class Box<T> {
        private T value;
        private Class<?> typeClass;
        
        public Box(T value) {
            this.value = value;
            this.typeClass = value.getClass(); // Store actual runtime class
        }
        
        public T get() {
            return value;
        }
        
        public Class<?> getTypeClass() {
            return typeClass;
        }
    }
    
    /**
     * Base generic class to demonstrate bridge methods.
     * 
     * After type erasure, this class becomes essentially:
     * static class Node {
     *     protected Object data;
     *     public Node(Object data) { this.data = data; }
     *     public Object getData() { return data; }
     * }
     * 
     * @param <T> The type of data stored in the node
     */
    static class Node<T> {
        protected T data;
        
        public Node(T data) {
            this.data = data;
        }
        
        public T getData() {
            return data;
        }
    }
    
    /**
     * Subclass with Integer type.
     * 
     * BRIDGE METHOD EXAMPLE:
     * After type erasure, Node.getData() returns Object,
     * but IntNode.getData() returns Integer.
     * 
     * To make this work, the compiler generates a bridge method in IntNode:
     * public Object getData() {
     *     return this.getData(); // Calls the Integer-returning method
     * }
     * 
     * This bridge method overrides Node's getData() method and delegates
     * to IntNode's specific implementation, allowing polymorphism to work
     * correctly with generics.
     * 
     * OCP EXAM TIP:
     * Understanding bridge methods is important for the exam.
     * They're synthetic methods created by the compiler to maintain
     * the proper inheritance relationship after type erasure.
     */
    static class IntNode extends Node<Integer> {
        public IntNode(Integer data) {
            super(data);
        }
        
        @Override
        public Integer getData() {
            System.out.println("IntNode's getData() called");
            return data;
        }
    }
    
    /**
     * Subclass with String type.
     * 
     * Similar to IntNode, the compiler generates a bridge method:
     * public Object getData() {
     *     return this.getData(); // Calls the String-returning method
     * }
     * 
     * CONCEPTUAL CHALLENGE:
     * Notice that both IntNode and StringNode appear to have the same bridge method
     * signature after erasure. This would normally be a method collision,
     * but it works because bridge methods are synthetic and handled specially
     * by the JVM at runtime.
     */
    static class StringNode extends Node<String> {
        public StringNode(String data) {
            super(data);
        }
        
        @Override
        public String getData() {
            System.out.println("StringNode's getData() called");
            return data;
        }
    }
}
